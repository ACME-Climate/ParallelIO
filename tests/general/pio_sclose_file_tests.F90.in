! Get a block cyclic decomposition
! If force_rearrange is FALSE, the decomposition is such that
! # All even procs have VEC_LOCAL_SZ elements
! # All odd procs have VEC_LOCAL_SZ + 1 elements
! e.g. For VEC_LOCAL_SZ = 2,
! e.g. 1)    [1,2] [3,4,5] [6,7]
! e.g. 2)    [1,2] [3,4,5] [6,7] [8,9,10]
! e.g. 3)    [1,2] [3,4,5] [6,7] [8,9,10] [11,12]
! If force_rearrange is TRUE, the decomposition is such that,
! If possible, the even rank "exchanges" elements with the next
! higher ranked odd proc.
! This for example can be used to force rearrangement when reading
! or writing data.
! e.g. For VEC_LOCAL_SZ = 2,
! e.g. 1)    [3,4,5] [1,2] [6,7]
! e.g. 2)    [3,4,5] [1,2] [8,9,10] [6,7]
! e.g. 3)    [3,4,5] [1,2] [8,9,10] [6,7] [11,12]
SUBROUTINE get_1d_bc_info(rank, sz, dims, start, count, force_rearrange)
  integer, parameter :: VEC_LOCAL_SZ = 7
  integer, intent(in) :: rank
  integer, intent(in) :: sz
  integer, dimension(1), intent(out) :: dims
  integer, dimension(1), intent(out) :: start
  integer, dimension(1), intent(out) :: count
  logical, intent(in) :: force_rearrange

  logical :: is_even_rank
  integer :: num_odd_procs, num_even_procs
  integer :: iodd, ieven

  is_even_rank = .false.
  if (mod(rank, 2) == 0) then
    is_even_rank = .true.
  end if
  num_odd_procs = sz / 2
  num_even_procs = sz - num_odd_procs
  dims(1) = num_even_procs * VEC_LOCAL_SZ + num_odd_procs * (VEC_LOCAL_SZ + 1)
  ! Number of odd and even procs before this rank
  iodd = rank / 2
  ieven = (rank + 1) / 2
  if(force_rearrange) then
    ! Make sure that we force rearrangement
    if (is_even_rank) then
      if(rank + 1 < sz) then
        ! Force rearrangement
        count(1) = VEC_LOCAL_SZ + 1
        start(1) = ieven * VEC_LOCAL_SZ + iodd * (VEC_LOCAL_SZ + 1) + (VEC_LOCAL_SZ) + 1
      else
        count(1) = VEC_LOCAL_SZ
        start(1) = ieven * VEC_LOCAL_SZ + iodd * (VEC_LOCAL_SZ + 1) + 1
      end if
    else
      ! For all odd procs there is an even lower ranked, rank-1, proc
      ! So force rearrangement
      count(1) = VEC_LOCAL_SZ
      start(1) = ieven * VEC_LOCAL_SZ + iodd * (VEC_LOCAL_SZ + 1) - (VEC_LOCAL_SZ) + 1
    end if
  else
    if (is_even_rank) then
      count(1) = VEC_LOCAL_SZ
    else
      count(1) = VEC_LOCAL_SZ + 1
    end if
    start(1) = ieven * VEC_LOCAL_SZ + iodd * (VEC_LOCAL_SZ + 1) + 1
  end if

END SUBROUTINE

! Test block cyclic interface
! Write and read back data on multiple (two) files on the same iosystem
! The data is written out with one decomp and read with another
PIO_TF_TEMPLATE<PIO_TF_PREDEF_TYPENAME PIO_TF_DATA_TYPE, PIO_TF_PREDEF_TYPENAME PIO_TF_FC_DATA_TYPE>
PIO_TF_AUTO_TEST_SUB_BEGIN nc_wr_rd_mfile_1d_bc
  implicit none
  type(var_desc_t)  :: pio_var_file1, pio_var_file2
  type(file_desc_t) :: pio_file1, pio_file2
  character(len=PIO_TF_MAX_STR_LEN) :: filename1 = "test_pio_sclose_ftests.testfile1"
  character(len=PIO_TF_MAX_STR_LEN) :: filename2 = "test_pio_sclose_ftests.testfile2"
  character(len=*), parameter :: PIO_VAR_NAME = 'PIO_TF_test_var'
  type(io_desc_t) :: wr_iodesc, rd_iodesc
  integer, dimension(:), allocatable :: wr_compdof, rd_compdof
  integer, dimension(1) :: start, count
  PIO_TF_FC_DATA_TYPE, dimension(:), allocatable :: rbuf, wbuf, exp_val
  integer, dimension(1) :: dims
  integer :: pio_dim_file1, pio_dim_file2
  integer :: i, ierr, lsz
  ! iotypes = valid io types
  integer, dimension(:), allocatable :: iotypes
  character(len=PIO_TF_MAX_STR_LEN), dimension(:), allocatable :: iotype_descs
  integer :: num_iotypes
  ! Write with rearrangement and read with no rearrangement
  logical :: enable_rd_rearr = .false.
  logical :: enable_wr_rearr = .true.

  ! Set the decomposition for writing data - forcing rearrangement
  call get_1d_bc_info(pio_tf_world_rank_, pio_tf_world_sz_, dims,&
         start, count, enable_wr_rearr)
  allocate(wbuf(count(1)))
  allocate(wr_compdof(count(1)))
  do i=1,count(1)
    wbuf(i) = start(1) + i - 1
    wr_compdof(i) = start(1) + i - 1
  end do

  ! Set the decomposition for reading data - different from the write decomp
  call get_1d_bc_info(pio_tf_world_rank_, pio_tf_world_sz_, dims,&
         start, count, enable_rd_rearr)
  allocate(rbuf(count(1)))
  allocate(rd_compdof(count(1)))
  allocate(exp_val(count(1)))
  do i=1,count(1)
    rd_compdof(i) = start(1) + i -1
    ! Expected value, after reading, is the same as the compdof
    exp_val(i) = rd_compdof(i)
  end do

  num_iotypes = 0
  call PIO_TF_Get_nc_iotypes(iotypes, iotype_descs, num_iotypes)
  do i=1,num_iotypes
    call PIO_initdecomp(pio_tf_iosystem_, PIO_TF_DATA_TYPE, dims, wr_compdof, wr_iodesc)

    PIO_TF_LOG(0,*) "Testing : PIO_TF_DATA_TYPE : ", iotype_descs(i)
    ierr = PIO_createfile(pio_tf_iosystem_, pio_file1, iotypes(i), filename1, PIO_CLOBBER) 
    PIO_TF_CHECK_ERR(ierr, "Could not create file " // trim(filename1))

    ierr = PIO_createfile(pio_tf_iosystem_, pio_file2, iotypes(i), filename2, PIO_CLOBBER) 
    PIO_TF_CHECK_ERR(ierr, "Could not create file " // trim(filename2))

    ierr = PIO_def_dim(pio_file1, 'PIO_TF_test_dim', dims(1), pio_dim_file1)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a dim : " // trim(filename1))

    ierr = PIO_def_dim(pio_file2, 'PIO_TF_test_dim', dims(1), pio_dim_file2)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a dim : " // trim(filename2))

    ierr = PIO_def_var(pio_file1, PIO_VAR_NAME, PIO_TF_DATA_TYPE, (/pio_dim_file1/), pio_var_file1)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a var : " // trim(filename1))

    ierr = PIO_def_var(pio_file2, PIO_VAR_NAME, PIO_TF_DATA_TYPE, (/pio_dim_file2/), pio_var_file2)
    PIO_TF_CHECK_ERR(ierr, "Failed to define a var : " // trim(filename2))

    ierr = PIO_enddef(pio_file1)
    PIO_TF_CHECK_ERR(ierr, "Failed to end redef mode : " // trim(filename1))

    ierr = PIO_enddef(pio_file2)
    PIO_TF_CHECK_ERR(ierr, "Failed to end redef mode : " // trim(filename2))

    ! Write the variable out
    call PIO_write_darray(pio_file1, pio_var_file1, wr_iodesc, wbuf, ierr)
    PIO_TF_CHECK_ERR(ierr, "Failed to write darray : " // trim(filename1))

    ! Write the variable out
    call PIO_write_darray(pio_file2, pio_var_file2, wr_iodesc, wbuf, ierr)
    PIO_TF_CHECK_ERR(ierr, "Failed to write darray : " // trim(filename2))

    ! Soft close
    call PIO_closefile(pio_file1)
    call PIO_closefile(pio_file2)

    call PIO_freedecomp(pio_tf_iosystem_, wr_iodesc)

    ! Reinitializing the testing framework
    ! - This includes finalizing the iosystem and hence data should
    !   be synced even for "soft close"
    call PIO_TF_Reinit()
    call PIO_initdecomp(pio_tf_iosystem_, PIO_TF_DATA_TYPE, dims, rd_compdof, rd_iodesc)

    ierr = PIO_openfile(pio_tf_iosystem_, pio_file1, iotypes(i), filename1, PIO_nowrite)
    PIO_TF_CHECK_ERR(ierr, "Could not reopen file " // trim(filename1))

    ierr = PIO_openfile(pio_tf_iosystem_, pio_file2, iotypes(i), filename2, PIO_nowrite)
    PIO_TF_CHECK_ERR(ierr, "Could not reopen file " // trim(filename2))

    ierr = PIO_inq_varid(pio_file1, PIO_VAR_NAME, pio_var_file1)
    PIO_TF_CHECK_ERR(ierr, "Could not inq var : " // trim(filename1))

    ierr = PIO_inq_varid(pio_file2, PIO_VAR_NAME, pio_var_file2)
    PIO_TF_CHECK_ERR(ierr, "Could not inq var : " // trim(filename2))

    rbuf = 0
    call PIO_read_darray(pio_file1, pio_var_file1, rd_iodesc, rbuf, ierr)
    PIO_TF_CHECK_ERR(ierr, "Failed to read darray : " // trim(filename1))

    PIO_TF_CHECK_VAL((rbuf, exp_val), "Got wrong val")

    rbuf = 0
    call PIO_read_darray(pio_file2, pio_var_file2, rd_iodesc, rbuf, ierr)
    PIO_TF_CHECK_ERR(ierr, "Failed to read darray : " // trim(filename2))

    PIO_TF_CHECK_VAL((rbuf, exp_val), "Got wrong val")

    call PIO_closefile(pio_file1)
    call PIO_closefile(pio_file2)

    call PIO_deletefile(pio_tf_iosystem_, filename1);
    call PIO_deletefile(pio_tf_iosystem_, filename2);

    call PIO_freedecomp(pio_tf_iosystem_, rd_iodesc)

    call PIO_TF_Reinit()
  end do

  deallocate(wr_compdof)
  deallocate(rd_compdof)

  if(allocated(iotypes)) then
    deallocate(iotypes)
    deallocate(iotype_descs)
  end if

  deallocate(exp_val)
  deallocate(rbuf)
  deallocate(wbuf)
PIO_TF_AUTO_TEST_SUB_END nc_wr_rd_mfile_1d_bc
